write.bed <- function(.x,f){
  write.table(x = .x, file = f, sep ="\t",
              col.names = F, row.names = F,
              quote = F)
}

# Produccing a GTF file from Homer's output -------------------------------
#' Merges close peaks
#'
#' 
#' Combines overlapping or "book-ended" peaks detected by Homer findPeaks into
#' one peak.
#'
#' @param bedtools.path The path to bedtools. (e.g "/path/to/bedtools/bin/".
#' End with "/", leave "" if bedtools is in your PATH environment variable)
#' @param peaks.file The path to the output file of Homer findPeaks.
#'  (e.g "/path/to/Peak").
#'
#'  The function reads the output file generated by Homer findPeaks. It
#'  Renders it into a bed file, sort it, and then merge peaks that are
#'  less than 100 (nt) apart using bedtools merge.
#' @return Writes a bed file 'merge.peakfile.bed' with the merged peaks
#'   into the . directory created by scAPA.script.R
merge_peaks <- function(bedtools.path, path, peaks.file){
  # home_dir <- getwd()
  # on.exit(setwd(home_dir))
  # setwd(path)
  readHomerfile.command <- paste0('awk \'BEGIN{OFS = "\t"}{if(NR>34) print $2, $3, $4, "',
                                ',.",".",$5}\' ', peaks.file,
                                ' > ./notsorted_notmerged_peak.bed')
  system(command = readHomerfile.command, wait = T)
# Sort the bed using bedtools Sort (required for bedtools merge)
bedtools.sort.command <- paste0(bedtools.path, "bedtools sort -i ./notsorted",
                                 "_notmerged_peak.bed > ./notmerged_peak.bed")
system(command = bedtools.sort.command, wait = T)
system(command = "rm ./notsorted_notmerged_peak.bed", wait = T)
# Merge using bedtools merge
bedtools.merge.command <- paste0(bedtools.path,
                                 "mergeBed -d 100 -s -c 6 -o distinct -i ",
                                 "./notmerged_peak.bed > ./merge.peakfile")
system(command = bedtools.merge.command, wait = T)
#Turning the output into a bed file
render.tobed.command <- paste0('awk \'BEGIN{OFS = "\t"}{print $1, $2, $3, ',
                               '".",".",$4}\' ./merge.peakfile > .',
                               '/merge.peakfile.bed')
system(command = render.tobed.command, wait = T)
system(command = "rm ./merge.peakfile", wait = T)
system(command = "rm ./notmerged_peak.bed", wait = T)
}


# Create GTF file ---------------------------------------------------------

#' Creates a GTF file from the peaks' bed file
#'
#' Creat a GTF file from the peaks' bed file. It uses bedtools intersect to
#' intersect the bed with a 3' UTR GTF. Then, it process the intersection file
#' into a GTF file. Lastly, it adds a peak idex to the peak ID. The most 5' peak
#' in the 3' UTR gets 1, and the next one 2, ,ect.
#'
#' @param org The organism: "Hs" for human (hg19), "Mm" for mouse (mm10).
#' @param bed.name The path to the bed file to be intersected
#' @param bedtools.path The path to bedtools. (e.g "/path/to/bedtools/bin/".
#' End with "/", leave "" if bedtools is in your PATH environment variable)
#'
#' @return a data.frame containing the peak's GTF. Peak ID's consists of the
#'  gene's ensembl ID, the UTR index, and the peak index ID:
#'   <ensembl ID>_<UTR index>_<Peak index>. e.g: ENSMUSG00000051951.5_1_2
#'   has ensembl ID: ENSMUSG00000051951.5, UTR index: 1, peak index 2.

# create_GTF <- function(org, path, bed.name, bedtools.path) {
#   # home_dir <- getwd()
#   # on.exit(setwd(home_dir))
#   # setwd(path)
#   if (org == "Mm") {
#     data("threeprimeUTRs_mm10_M18.gtf")
#     write.table(x = threeprimeUTRs_mm10_M18.gtf,
#                 file = "./threeprimeUTRs_mm10_M18.gtf", sep = "\t",
#                 quote = F, row.names = F, col.names = F)
#     intersect.command <- paste0(bedtools.path, "bedtools intersect -wa ",
#                                 "-wb -s -a ./", bed.name,
#                                 " -b ./threeprimeUTRs_mm10_M18.gtf >",
#                                 " ./annotatedpeaks")
#   }
#   if (org == "Hs") {
#     data(threeprimeUTRs_hg19_v25_lift37.gtf)
#     write.table(x = threeprimeUTRs_hg19_v25_lift37.gtf,
#                 file = "./threeprimeUTRs_hg19_v25_lift37.gtf", sep = "\t",
#                 quote = F, row.names = F, col.names = F)
#     intersect.command <- paste0(bedtools.path, "bedtools intersect -wa ",
#                                 "-wb -s -a ./", bed.name,
#                                 " -b ./threeprimeUTRs_hg19_v25_lift37.gtf >",
#                                 " ./annotatedpeaks")
#   }
#
#   system(command = intersect.command, wait = T)
#   peakstosort <- read.delim(file = "./annotatedpeaks", header = F)
#   peakstosort <- peakstosort[,c(1,8,9,2,3,12:15)]
#   colnames(peakstosort) <- paste0("V", 1:9)
#
#
#     peakstosort <- dplyr::group_by(peakstosort, V9)
#     #For peak index: utrs on the plus strand need descending order, minus ascending
#     peakstosort <- dplyr::mutate(peakstosort,
#                                  desire = ifelse(V7 == "+",
#                                                  dplyr::dense_rank(x = V4),
#                                                  dplyr::dense_rank(dplyr::desc(x = V4))))
#     #this is a column for changing the gene name
#     peakstosort <- dplyr::mutate(peakstosort,
#                                  name = paste0("_", desire, "; transcript_type"))
#     peakstosort$V9 <- as.character(peakstosort$V9)
#         peakstosort <- dplyr::mutate(peakstosort,
#                                      name2 = paste0("_", desire, "; transcript_id"))
#         for (i in 1:nrow(peakstosort)) {
#             peakstosort$V9[i] <- gsub(peakstosort$V9[i],
#                                       pattern = "; transcript_id",
#                                       replacement = peakstosort$name2[i])
#             #changing the gene name
#             peakstosort$V9[i] <- gsub(peakstosort$V9[i],
#                                       pattern = "; transcript_type",
#                                       replacement = peakstosort$name[i])
#         }
#     peakstosort <- peakstosort[, 1:9]
#     peakstosort
# }

intersect_peaks <- function(org, path, bed.name, bedtools.path, introns = F) {
  # home_dir <- getwd()
  # on.exit(setwd(home_dir))
  # setwd(path)
  if(!introns){
  if (org == "Mm") {
    data(mm10.utr)
    write.bed(.x = mm10.utr,
                f = "./threeprimeUTRs.bed")
  }
  if (org == "Hs") {
    data(hg19.utr)
    write.table(x = hg19.utr,
                file = "./threeprimeUTRs.bed", sep = "\t",
                quote = F, row.names = F, col.names = F)

  }
  intersect.command <- paste0(bedtools.path, "bedtools intersect -wa ",
                              "-wb -s -a ./", bed.name,
                              " -b ./threeprimeUTRs.bed >",
                              " ./annotatedpeaks")
  system(command = intersect.command, wait = T)

  peakstosort <- read.delim(file = "./annotatedpeaks", header = F)

  peakstosort <- peakstosort[,c(1,2,3,10,4,6)]
  colnames(peakstosort) <- paste0("V", 1:6)


  peakstosort <- dplyr::group_by(peakstosort, V4)
  #For peak index: utrs on the plus strand need descending order, minus ascending

  peakstosort <- dplyr::group_by(peakstosort, V4)
  #For peak index: utrs on the plus strand need descending order, minus ascending
  peakstosort <- dplyr::mutate(peakstosort,desire = ifelse(V6 == "+",
                                           dplyr::dense_rank(x = V3),
                                           dplyr::dense_rank(dplyr::desc(x = V3))))
  #this is a column for changing the gene name
  peakstosort$V4 <- paste0(as.character(peakstosort$V4), "_", peakstosort$desire)
  peakstosort <- peakstosort[,-7]
  system(command = "rm ./threeprimeUTRs.bed", wait = T)
  system("rm ./annotatedpeaks", wait = T)
  }
  if(introns){
    if (org == "Mm") {
      data(mm10.introns)
      write.bed(.x = mm10.introns,
                  f= "./introns.bed")
      data(mm10.utr)
      utrs <- mm10.utr
    }
    if (org == "Hs") {
        data(hg19.introns)
        write.bed(.x = hg19.introns,
                  f= "./introns.bed")
        data(hg19.utr)
        utrs <- hg19.utr
      }
    intersect.command <- paste0(bedtools.path, "bedtools intersect -wa ",
                                "-wb -s -a ./", bed.name,
                                " -b ./introns.bed >",
                                " ./annotatedpeaks")
    system(command = intersect.command, wait = T)

    peakstosort <- read.delim(file = "./annotatedpeaks", header = F)

    peakstosort <- peakstosort[,c(1,2,3,10,4,6)]
    colnames(peakstosort) <- paste0("V", 1:6)


    peakstosort <- dplyr::group_by(peakstosort, V4)
    #For peak index: utrs on the plus strand need descending order, minus ascending

    peakstosort <- dplyr::group_by(peakstosort, V4)
    #For peak index: utrs on the plus strand need descending order, minus ascending
    peakstosort <- dplyr::mutate(peakstosort,desire = ifelse(V6 == "+",
                                                             dplyr::dense_rank(x = V3),
                                                             dplyr::dense_rank(dplyr::desc(x = V3))))
    #this is a column for changing the gene name
    peakstosort$V4 <- paste0(as.character(peakstosort$V4), "_", peakstosort$desire)
    peakstosort <- peakstosort[,-7]
    peakstosort <- rbind.data.frame(peakstosort, utrs)
    system(command = "rm ./introns.bed", wait = T)
    system("rm ./annotatedpeaks", wait = T)
  }
  peakstosort
}


# Mclust ------------------------------------------------------------------

merge_covrage <- function(files){
covrage.list <- lapply(X = samples, read.delim, header = F)
chnge_col <- function(x){
  x$V7 <- x$V7 + x$V2 -1
  x}
lapply(X = covrage.list, FUN = chnge_col)
covrages <- do.call(what = rbind.data.frame, args = covrage.list)
covrages  <- dplyr::group_by(covrages, V1, V2, V3, V4, V5, V6, V7)
covrages  <- dplyr::summarise(covrages, sum(V8))
covrages <- as.data.frame(covrages)
covrages <- split(covrages, covrages$V4)
covrages
}


creat_mclus <- function(itemNumber) {
  wig <- peaks.wig[[itemNumber]]
  bed <- wig[1,7:12]
  out <- as.data.frame(bed)
  if (bed[1,3] - bed[1,2] > 100){
    vec <-numeric()
    for(i in 1:nrow(wig)) {
      if (wig[,2][i] - wig[,3][i]-1 != 0){
        vec <- c(vec, rep(x = (wig[,2][i]):(wig[,3][i]-1), times = wig[,4][i]))
      } else {vec <- c(vec, rep(x = (wig[,2][i]), times = wig[,4][i]))}
    }
    mod2 <- Mclust(vec, G =2, modelNames = "E")
    meandiff <- abs(mod2$parameters$mean[1]-mod2$parameters$mean[2])
    diff <- meandiff/sqrt(mod2$parameters$variance$sigmasq[1])
    if ((diff > 3) & (meandiff > 75)){
      one <- bed
      one[,3] <- max(vec[mod2$classification == 1])
      two <- bed
      two[,2] <- one[,3] + 1
      out <- rbind.data.frame(one,two)
    }
  }
  out
}




# saf ---------------------------------------------------------------------



creat_saf <- function(bed){
  bed[,4] <- gsub(x = bed[,4], pattern = "_\\d*$", replacement = "")
  colnames(bed) <- paste0("V", 1:6)
  bed <- dplyr::group_by(bed, V4)
  #For peak index: utrs on the plus strand need descending order, minus ascending
  bed <- dplyr::mutate(bed,desire = ifelse(V6 == "+",
                                           dplyr::dense_rank(x = V3),
                                           dplyr::dense_rank(dplyr::desc(x = V3))))
  #this is a column for changing the gene name
  bed$V4 <- paste0(as.character(bed$V4), "_", bed$desire)
  saf <- as.data.frame(bed[,c(4,1,2,3,6)])
  colnames(saf) <- c("GeneID", "Chr",	"Start","End","Strand")
  saf
}

# Reading downstream sequance -----------------------------------------------
read_down.seq <- function(saf, char.length.path, fasta.path, chr.modify = T, l=-1, r=200) {
  sc <- options()
  sc <- sc$scipen
  options(scipen=99999)
  on.exit(options(scipen=sc))
  bed <- saf[,c(2,3,4,1,1,5)]
  bed[,5] <- "."
  colnames(bed) <- c("Chr", "Start", "End", "Peak_ID", "f2", "Strand")
  bed[,4] <- gsub(x =bed[,4], pattern = ";.*", replacement = "")
  bed[,4] <- gsub(x =bed[,4], pattern = "gene_id ", replacement = "")
  find_peak_edge <- function(x) {
    x$Start <- ifelse(x$Strand == "+", x$End - 1, x$Start)
    x$End <- ifelse(x$Strand == "+", x$End, x$Start + 1)
    x
  }
  bed.edge <- find_peak_edge(bed)
  #modify chromosoms names
  if(chr.modify){
  bed.edge[,1] <- ifelse(bed.edge$Chr == "MT", "chrM", paste0("chr",
                                                              bed.edge[,1]))
  }
  write.table(bed.edge, file = "./bed.edge", sep = "\t", quote = F,
              col.names = F, row.names = F)
  slop.command <- paste0(bedtools.path, "bedtools slop -s -r ",r," -l ",l,
                         " -g ",  char.length.path, " -i ./bed.edge > ",
                         "./bed.extended")
  system(command = slop.command, wait = T)
    bed.fasta.command <- paste0(bedtools.path, "bedtools getfasta -s -tab",
                                " -fi ", fasta.path,
                                " -bed ./bed.extended -fo ",
                                "./bed.extended.fa")
  system(command = bed.fasta.command, wait = T)
  fasta <- read.delim(file = "./bed.extended.fa", header = F,
                      col.names = c("region", "seq"))
  out <- cbind.data.frame(bed[,-5], fasta[,-1])
  colnames(out)[6] <- "Downstream_Seq"
  system(command = "rm ./bed.extended.fa ./bed.extended", wait = T)
  out
}


# Proccess DigitalExpression output and cluster files ----------------------------------

process_cluster.files <- function(sample.names){
path.clus.files <- paste0("../clusters_", sample.names,".txt")
clusters <- lapply(X = path.clus.files, FUN = read.delim, header = F)
#As diffrent samples may have identical cell BC, we replace the suffix (-1), to
# an index corresponding to the sample. The same is done for the expression file
# file.
for (nsample in 1:length(clusters)) {
  clusters[[nsample]][,1] <- gsub(x =clusters[[nsample]][,1],
                                  pattern = "-\\d*$",
                                  replacement = "-1")

  clusters[[nsample]][,1] <- paste0(sample.names[nsample],"_", clusters[[nsample]][,1])
  }
do.call(what = "rbind", args = clusters)
}

process_expression <- function(org, path.exp.mats) {
expression[is.na(expression)] <- 0
colnames(expression) <- gsub(x = colnames(expression), pattern = "[.]",
                           replacement = "-")
expression
}


