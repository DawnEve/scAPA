{
    "collab_server" : "",
    "contents" : "# #!/usr/bin/env Rscript\n#\nscript.args = commandArgs(trailingOnly=TRUE)\nif (((script.args[1] == \"-h\") | (script.args[1] == \"--help\") | (is.na(script.args[1])))) {\n  cat(\"\\n Usage: scAPA.script.R -p <path.to.files> -org <organism> [options]\\n\\n\",\n      \"Options:\\n\\n\\t-p \\tThe path to bam files, cell cluster files, list.bams.txt\",\n      \" and cell.cluster.list.txt\\n\\t\\t/path/to/files\\n\\n\\t-org \\tOrganism, either Mm\",\n      \"for mouse, or Hs for human\\n\\n\\t-cpm\\tConsider only peaks with more than\",\n      \" a total sum of CPMs over all cell clusters larger than -cpm.\\n\\t\\tDefult\",\n      \" value: 10\\n\\n\\t-a\\tNumeric value, filter out peaks with -a consecutive As\",\n      \"in the region -u to -d downstream thire 3' edge.\\n\\t\\tDefult value: 8\\n\\n\\t-u\",\n      \"\\tNumeric value, filter out peaks with -a consecutive As in the region \",\n      \"-u to -d downstream thire 3' edge.\\n\\t\\tDefult value: 10\\n\\n\\t-d\\tNumeric \",\n      \"value, filter out peaks with -a consecutive As in the region -u to -d \",\n      \"downstream thire 3' edge.\", \"\\n\\t\\tDefult value: 140\\n\\n\\t-wig\\tweather \",\n      \"to generate cluster wig files. Defult value: false\\n\\n\")\n  q(save=\"no\", status=1, runLast=FALSE)\n}\n\n# Load R packeges and function scripts---------------------------------------------------------\nrequire(dplyr, lib.loc = \"/home/elkon/eldadshulman/Rfive\", warn.conflicts = F)\nrequire(tidyr, lib.loc = \"/home/elkon/eldadshulman/Rfive\", warn.conflicts = F)\nrequire(ggplot2, lib.loc = \"/home/elkon/eldadshulman/Rfive\", warn.conflicts = F)\nrequire(EnvStats,lib.loc = \"/home/elkon/eldadshulman/Rfive\", warn.conflicts = F)\nrequire(scAPA, lib.loc = \"/home/elkon/eldadshulman/Rfive\" , warn.conflicts = F)\nrequire(Rsubread, lib.loc = \"/home/elkon/eldadshulman/Rfive\" , warn.conflicts = F)\nrequire(pbapply, lib.loc = \"/home/elkon/eldadshulman/Rfive\" , warn.conflicts = F)\nrequire(parallel, warn.conflicts = F)\nrequire(mclust, warn.conflicts = F)\n# Read in user's arguments ------------------------------------------------\n\n#Script arguments in this order:\n#<path.to.files> the path to the directory with the experiment bams, cluster text files,\n# bam.file.txt, cell.cluster.file.txt.\n# <organism> Organism Mm for mouse (mm10) and Hs for human (hg19)\n\n# test arguments:\n\nif (length(script.args) == 0) {\n  stop(paste0(\"scAPA.script.R -p <path.to.files> -org <organism>.\\n\",\n              \"The following arguments are optional: -cpm <CPM.cuttoff>\",\n              \"  -a <A.number> -u <filter.border.left> -d \",\n              \"<filter.border.right>\"), call.=FALSE)\n}\n\nif (length(script.args) < 2) {\n  stop(paste0(\"At least two argument must be supplied (path to files \",\n              \"and organism (Hs/Mm)\"), call.=FALSE)\n}\nscript.args <- paste(script.args, collapse = \" \")\nscript.args <- paste0(script.args, \" \")\n#Read arguments\npath.to.files <- read_args(arg.string = \"-p\", arg = script.args)\norg <- read_args(arg.string = \"-org\", arg = script.args)\nif(!(org %in% c(\"Mm\", \"Hs\"))) {\n  stop(paste0(\"The second argument (organism) must be either Mm \",\n              \"(for mouse) or Hs (for human)\"),\n       call.=FALSE)\n}\n#The following arguments are optional. If not provided, defult values are set.\nCPM.cuttoff <- read_args(arg.string = \"-cpm\", defult = 10, arg = script.args)\nA.number <- read_args(arg.string = \"-a\", defult = 8, arg = script.args)\nfilter.border.left <-  read_args(arg.string = \"-u\", defult = 10, arg = script.args)\nfilter.border.right <-  read_args(arg.string = \"-d\", defult = 140, arg = script.args)\nwig <-  read_args(arg.string = \"-wig\", defult = \"false\", arg = script.args)\nscript.WD <- getwd()\n##data.dir <-paste0(script.WD, \"/data/\")\n#Read in configuration file\nconfigfile <- as.character(read.delim(\"configfile.txt\", header = F)[,1])\nconfigfile[configfile == \"PATH\"] <- \"\"\nif(org == \"Mm\"){\n  char.length.path <- configfile[2]\n  fasta.path <- configfile[4]\n}\nif(org == \"Hs\"){\n  char.length.path <- configfile[6]\n  fasta.path <- configfile[8]\n}\ndrop.seq.tools.path <- configfile[10]\nsamtools.path <- configfile[12]\numi_tools.path <- configfile[14]\nhomer.path <- configfile[16]\nbedtools.path <- configfile[18]\n# Read in bam.file.txt and cell.clusterfile.txt ---------------------------\nsetwd(path.to.files)\nbams.files <- list.files(pattern = \".bam$\")\nsamples.vector <- gsub(x = bams.files, pattern = \".bam\", replacement = \"\")\nbams <- paste(bams.files, collapse = \" \")\nsamples <- gsub(x = bams, pattern = \".bam\", replacement = \"\")\nif(!dir.exists(\"scAPA\")) dir.create(\"scAPA\")\nif(!dir.exists(\"scAPA/Log.files\")) dir.create(\"scAPA/Log.files\")\nif(!dir.exists(\"scAPA/temp\")) dir.create(\"scAPA/temp\")\nif(!dir.exists(\"scAPA/outs\")) dir.create(\"scAPA/outs\")\nsetwd(paste0(path.to.files, \"/scAPA\"))\nlog.files.messege <- paste0(\"\\nThe script's log file is written into: \",\n                            path.to.files, \"/scAPA/scAPA.script.log.\\n\",\n                            \"The log files of the tools used are \",\n                            \"written to the directory: \", path.to.files,\n                            \"/scAPA/Log.files.\\n\\n\")\ncat(x = log.files.messege)\nscript.start.messsege <- paste0(Sys.time(), \"\\t Started scAPA.script.R.\\n\",\n                                \"-p = \", path.to.files, \"\\n\",\n                                \"-org = \", org, \"\\n\",\n                                \"-cpm = \",CPM.cuttoff, \"\\n\",\n                                \"-a = \", A.number, \"\\n\",\n                                \"-u = \",filter.border.left, \"\\n\",\n                                \"-d = \", filter.border.right, \"\\n\")\nwrite(x = script.start.messsege, file = \"scAPA.script.log\", append = F)\n# Our pipeline consists of the following 5 steps:\n#   1.\tFinding 3'UTR peaks\n# 2.\tQuantifying the usage of each peak in each cell cluster\n# 3.\tFiltering peaks\n# 4.\tDetecting dynamical APA events\n# 5.\tInferring global trends\n\n#   1.\tFinding 3'UTR peaks\n# PCR duplicates removal ---------------------------------------------------------------\n# i.\tPCR duplicates are removed using UMI-tools dedup. As UMI tools dedup\n# requires that each line in the BAM file has a molecular barcode tag, first\n# use Drop-seq tools to filter the BAMs, leaving only reads with corrected\n# molecular barcode tag\n\n#Filter tags -------------------------------------------------------------\n\n# sam.tobamcommand <- paste0(\"for sample in \", samples, \"; do samtools view -S -b\",\n#                              \" ./temp/UB.${sample}.sam > ./temp/UB.${sample}.bam;\",\n#                            \" rm ./temp/UB.${sample}.sam; done\")\n# filter.bam.command <- paste0(\"for sample in \", samples, \"; do samtools view -H \",\n#                               \"../${sample}.bam > ./temp/UB.${sample}.sam;\",\n#                              \" samtools view ../${sample}.bam | grep \",\n#                              \"UB:Z: >> ./temp/UB.${sample}.sam; done\")\n# print(filter.bam.command)\n# print(sam.tobamcommand )\n# system(command = filter.bam.command , wait = T)\n# system(command = sam.tobamcommand , wait = T)\n# # samtools index ----------------------------------------------------------\n# index.command <- paste0(\"sh -c 'for sample in \", samples, \" ; do \",\n#                         samtools.path, \"samtools index temp/UB.${sample}.bam\",\n#                         \" &> ./Log.files/Index.${sample}.out; done'\")\n# write_log_start(\"samtools index\", command = index.command)\n# print(index.command)\n# system(command = index.command, wait = T)\n# if(!all(file.exists(paste0(\"./temp/UB.\", samples.vector, \".bam.bai\")))) {\n#   write_log(stage = \"samtools index\", success = F)\n#   stop(\"samtools index did not end, shell script did NOT end!\")\n# }\n# write_log(stage = \"samtools index\")\n#\n# # umi_tools ---------------------------------------------------------------\n# umi_tools.command <- paste0(\"sh -c 'for sample in \", samples,\n#                             \" ;do \", umi_tools.path, \"umi_tools dedup -I \",\n#                             \"temp/UB.${sample}.bam -S temp/dedup.${sample}.bam\",\n#                             \" --method=unique --extract-umi-method=tag \",\n#                             \"--umi-tag=UB --cell-tag=CB &> \",\n#                             \"./Log.files/umi_tools.${sample}.out;\",\n#                             \" done'\")\n# write_log_start(\"umi_tools,\", command = umi_tools.command)\n# print(umi_tools.command)\n# system(command = umi_tools.command, wait = T)\n# if(!all(file.exists(paste0(\"temp/dedup.\", samples.vector, \".bam\")))) {\n#   write_log(stage = \"umi_tools\", success = F)\n#   stop(\"umi_tools did not end, shell script did NOT end!\")\n# }\n# write_log(stage = \"umi_tools\")\n# # system(command = \"rm temp/UB.*.bam*\", wait = T)\n# #\n#\n# # Peak detection -------------------------------------------------------\n# # i.\tUse Homer to create a tag directory (Tagdirectory) from all the PCR removed BAMs\n#\n# # makeTagDirectory --------------------------------------------------------\n# makeTagDirectory.command <- paste0(homer.path, \"makeTagDirectory ./temp/Tagdirectory \",\n#                                    \"./temp/dedup.* &> ./Log.files/\",\n#                                    \"makeTagDirectory.out\")\n# write_log_start(\"makeTagDirectory\", command = makeTagDirectory.command )\n# print(makeTagDirectory.command)\n# system(command = makeTagDirectory.command, wait = T)\n# if(!dir.exists(paste0(\"Tagdirectory\"))) {\n#   write_log(stage = \"makeTagDirectory\", success = F)\n#   stop(\"makeTagDirectory did not end, shell script did NOT end!\")\n# }\n# write_log(stage = \"makeTagDirectory\")\n#\n# # findPeaks ---------------------------------------------------------------\n# findPeaks.command <- paste0(homer.path,\"findPeaks ./temp/Tagdirectory -size 50 -frag\",\n#                             \"Length 100 -minDist 1 -strand separate -o \",\n#                             \"./temp/Peakfile &> ./Log.files/findPeaks.out\")\n# write_log_start(\"findPeaks,\",command = findPeaks.command)\n# print(findPeaks.command)\n# system(command = findPeaks.command, wait = T)\n# if(!file.exists(paste0(\"./temp/Peakfile\"))) {\n#   write_log(stage = \"findPeaks\", success = F)\n#   stop(\"findPeaks did not end, shell script did NOT end!\")\n# }\n# write_log(stage = \"findPeaks\")\n#\n\n# Peak analysis -----------------------------------------------------------\nsetwd(\"./temp\")\n# merge_peaks(bedtools.path = bedtools.path,\n#             peaks.file = \"Peakfile\", path = \"./\")\n# peaks.bed <- intersect_peaks(org = org, bed.name = \"./merge.peakfile.bed\",\n#                              path = \"\", bedtools.path = bedtools.path, introns = F)\n# write.bed(.x = peaks.bed, f = \"./peaks.bed\")\n# dedup.bams <- paste0(\"dedup.\",bams.files, collapse = \" \")\n# samtools.merge.commad <- paste0(samtools.path, \"samtools merge merged.bam \",\n#                                 dedup.bams)\n# print(samtools.merge.commad)\n# #system(command = samtools.merge.commad, wait = T)\n# wig.plus.command <- paste0(bedtools.path, \"bedtools genomecov -ibam merged.bam \",\n#                            \"-bg -strand + | awk 'BEGIN {OFS = \\\"\\t\\\"}{print $1\",\n#                            \", $2, $3, $4, \\\".\\\", \\\"+\\\"}' > merged.wig\")\n# print(wig.plus.command)\n# system(command = wig.plus.command, wait = T)\n# wig.minus.command <- paste0(bedtools.path, \"bedtools genomecov -ibam merged.bam \",\n#                             \"-bg -strand - | awk 'BEGIN {OFS = \\\"\\t\\\"}{print $1\",\n#                             \", $2, $3, $4, \\\".\\\", \\\"-\\\"}' >> merged.wig\")\n# print(wig.minus.command)\n# system(command = wig.minus.command, wait = T)\n# system(\"rm merged.bam\", wait = T)\n#\n# intersect.wig.command <- paste0(bedtools.path, \"bedtools intersect -s -wb \",\n#                                 \" -b peaks.bed -a merged.wig > intersected.wig\")\n# system(intersect.wig.command, wait = T)\n# peaks.wig <- read.delim(file = \"intersected.wig\", header = F)\n# peaks.wig <- split(x = peaks.wig, f = peaks.wig$V10, drop = T)\n# bed <- plyr::rbind.fill(parallel::mclapply(1:length(peaks.wig), FUN = creat_mclus,\n#                                            mc.cores=30, mc.preschedule=T))\n# utr.saf <- bed[,c(4,1,2,3,6)]\n#colnames(utr.saf) <- c(\"GeneID\", \"Chr\",\t\"Start\",\"End\",\"Strand\")\n# saveRDS(object = utr.saf, file = \"utr.saf.RDS\")\n# #if (introns){\n  # merge_peaks(bedtools.path = bedtools.path,\n  #             peaks.file = \"Peakfile\", path = \"./\")\n  # int.peaks.bed <- intersect_peaks(org = org, bed.name = \"./merge.peakfile.bed\",\n  #                              path = \"\", bedtools.path = bedtools.path,\n  #                              introns = T)\n  # int.peaks.bed  <- as.data.frame(int.peaks.bed)\n  # int.saf <- int.peaks.bed[,c(4,1,2,3,6)]\n#colnames(int.saf) <- c(\"GeneID\", \"Chr\",\t\"Start\",\"End\",\"Strand\")\n  # saveRDS(object = int.saf, file = \"int.saf.RDS\")\n# int.saf <- readRDS(\"int.saf.RDS\")\n#}\n# Split bams ------------------------------------------------------------\n\nallclusters <- character()\nfor(j in 1:length(samples.vector)) {\n  sample <- samples.vector[j]\n  list.file <- paste0(\"../../clusters_\",sample, \".txt\")\n  list.cells <- read.delim(file = list.file, header = F)\n  list.cells[,1] <- as.character(list.cells[,1])\n  list.cells <- split(x = list.cells, f = list.cells[,2],drop = T)\n  allclusters <- c(allclusters, names(list.cells))\n  for (i in 1:length(list.cells)){\n    cluster <- names(list.cells)[i]\n    cluster.cells <- list.cells[[i]][,1]\n    cluster.cells <- paste0(cluster.cells, collapse = \"|\")\n    # filter.bam.command <- paste0(\"for sample in \", samples, \"; do samtools view -H \",\n    #                               \"../${sample}.bam > ./temp/UB.${sample}.sam;\",\n    #                              \" samtools view ../${sample}.bam | grep \",\n    #                              \"UB:Z: >> ./temp/UB.${sample}.sam; done\")\n    # split.bam.command <- paste0(\"samtools view -h dedup.\", sample,\".bam | awk -v \",\n    #                             \"tag=\\\"CB:Z:[\",cluster.cells, \"]\\\" '($0 ~ /^@/ || \",\n    #                             \"index($0,tag)>0)' > \", sample, \"_\", cluster,\n    #                             \".sam\")\n    split.bam.command.a <- paste0(\"samtools view -H dedup.\", sample,\".bam \",\n                                \"> \", sample, \"_\", cluster,\n                                \".sam\")\n    split.bam.command.b <- paste0(\"samtools view dedup.\", sample,\".bam | LC_ALL=C egrep '\",\n                                cluster.cells, \"' >> \", sample, \"_\", cluster,\n                                \".sam\")\n    sam.tobam.command <- paste0(\"samtools view -h -S -b \", sample, \"_\", cluster,\n                                \".sam > \", sample, \"_\", cluster, \".bam\")\n    # print(split.bam.command)\n    print(sam.tobam.command)\n    system(command = split.bam.command.a, wait = T)\n    system(command = split.bam.command.b, wait = T)\n    system(command = sam.tobam.command, wait = T)\n    system(paste0(\"rm \", sample, \"_\", cluster, \".sam\"), wait = T)\n  }\n}\nclusters <- unique(allclusters)\nfor(i in 1:length(clusters)){\n  bams.to.merge <- paste0(samples.vector, \"_\", clusters[i], \".bam\",\n                          collapse = \" \")\n  samtools.merge.command <- paste0(\"samtools merge \", clusters[i],\".bam \",\n                                   bams.to.merge)\n  print(samtools.merge.command)\n  system(command = samtools.merge.command, wait = T)\n}\n\n\n# Read Counts -------------------------------------------------------------\nbam.cluster.files <- paste0(clusters,\".bam\", collapse = \" \")\ncounts <- featureCounts(files = bam.cluster.files ,isGTFAnnotationFile = F,\n                        annot.ext = utr.saf, largestOverlap = T, nthreads = 30)\nco <- cbind.data.frame(rownames(counts$counts), counts$counts)\ncolnames(co) <- paste0(\"Peak_ID\", clusters)\nmeta <- counts$annotation\nmeta <- meta[,c(2,3,4,1,6,5)]\nmetadata <- read_down.seq(saf = utr.saf,\n                          char.length.path = char.length.path,\n                          fasta.path = fasta.path,\n                          chr.modify = T)\naseq <- metadata[,c(4,6)]\n#if(introns){\ncounts_int <- featureCounts(files = bam.cluster.files ,isGTFAnnotationFile = F,\n                        annot.ext = int.saf, largestOverlap = T, nthreads = 30)\nco_int <- cbind.data.frame(rownames(counts_int$counts), counts_int$counts)\ncolnames(co_int) <- paste0(\"Peak_ID\", clusters)\nmeta_int <- counts_int$annotation\nmeta_int <- meta_int[,c(2,3,4,1,6,5)]\nmetadata_int <- read_down.seq(saf = int.saf,\n                          char.length.path = char.length.path,\n                          fasta.path = fasta.path,\n                          chr.modify = T)\naseq_int <- metadata_int[,c(4,6)]\na.int <- set_scAPAList(.clus.counts = co_int, .row.Data = meta_int, .down.seq = aseq_int)\nsaveRDS(object = a.int , file = \"a.int.RDS\")\na <- set_scAPAList(.clus.counts = co, .row.Data = meta, .down.seq = aseq)\na <- calc_cpm(a)\nkeep.cpm <- rowSums(a@norm$CPM) > 10\na.fil <- a[keep.cpm,]\nhas.Aseq <- find_internal_prim_seq(x = a.fil, int.priming.seq = \"AAAAAAAA\",\n                                   left = 10,\n                                   right = 140)\nkeep.int.pr <- as.vector(!has.Aseq[,2])\n\na.fil <-a.fil[which(keep.int.pr),]\n\nreasults <- set_scAPAreasults(a.fil)\nreasults <- test_APA(reasults)\nreasults <- calc_pAi_mat(reasults)\nreasults <- calc_p_pui_mat(reasults)\nprint(reasults)\nsystem(\"rm utr.peaks.bed\", wait = T)\nprint(table_brain)\nsystem(\"rm merged.wig\", wait = T)\nsystem(\"rm intersected.wig\", wait = T)\n",
    "created" : 1562759760538.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1918932558",
    "id" : "A285CD29",
    "lastKnownWriteTime" : 1562773022,
    "last_content_update" : 1562773022821,
    "path" : "/specific/netapp5_2/elkon/eldadshulman/scAPAscript/scAPAscript_mclust.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}