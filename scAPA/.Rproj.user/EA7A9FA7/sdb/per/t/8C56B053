{
    "collab_server" : "",
    "contents" : "write.bed <- function(.x,f){\n  write.table(x = .x, file = f, sep =\"\\t\",\n              col.names = F, row.names = F,\n              quote = F)\n}\n\n# Produccing a GTF file from Homer's output -------------------------------\n#' Merges close peaks\n#'\n#' Combines overlapping or “book-ended” peaks detected by Homer findPeaks into\n#'  one peak.\n#'\n#' @param bedtools.path The path to bedtools. (e.g \"/path/to/bedtools/bin/\".\n#' End with \"/\", leave \"\" if bedtools is in your PATH environment variable)\n#' @param peaks.file The path to the output file of Homer findPeaks.\n#'  (e.g \"/path/to/Peak\").\n#'\n#'  The function reads the output file generated by Homer findPeaks. It\n#'  Renders it into a bed file, sort it, and then merge peaks that are\n#'  less than 100 (nt) apart using bedtools merge.\n#' @return Writes a bed file 'merge.peakfile.bed' with the merged peaks\n#'   into the . directory created by scAPA.script.R\nmerge_peaks <- function(bedtools.path, path, peaks.file){\n  # home_dir <- getwd()\n  # on.exit(setwd(home_dir))\n  # setwd(path)\n  readHomerfile.command <- paste0('awk \\'BEGIN{OFS = \"\\t\"}{if(NR>34) print $2, $3, $4, \"',\n                                ',.\",\".\",$5}\\' ', peaks.file,\n                                ' > ./notsorted_notmerged_peak.bed')\n  system(command = readHomerfile.command, wait = T)\n# Sort the bed using bedtools Sort (required for bedtools merge)\nbedtools.sort.command <- paste0(bedtools.path, \"bedtools sort -i ./notsorted\",\n                                 \"_notmerged_peak.bed > ./notmerged_peak.bed\")\nsystem(command = bedtools.sort.command, wait = T)\nsystem(command = \"rm ./notsorted_notmerged_peak.bed\", wait = T)\n# Merge using bedtools merge\nbedtools.merge.command <- paste0(bedtools.path,\n                                 \"mergeBed -d 100 -s -c 6 -o distinct -i \",\n                                 \"./notmerged_peak.bed > ./merge.peakfile\")\nsystem(command = bedtools.merge.command, wait = T)\n#Turning the output into a bed file\nrender.tobed.command <- paste0('awk \\'BEGIN{OFS = \"\\t\"}{print $1, $2, $3, ',\n                               '\".\",\".\",$4}\\' ./merge.peakfile > .',\n                               '/merge.peakfile.bed')\nsystem(command = render.tobed.command, wait = T)\nsystem(command = \"rm ./merge.peakfile\", wait = T)\nsystem(command = \"rm ./notmerged_peak.bed\", wait = T)\n}\n\n\n# Create GTF file ---------------------------------------------------------\n\n#' Creates a GTF file from the peaks' bed file\n#'\n#' Creat a GTF file from the peaks' bed file. It uses bedtools intersect to\n#' intersect the bed with a 3' UTR GTF. Then, it process the intersection file\n#' into a GTF file. Lastly, it adds a peak idex to the peak ID. The most 5' peak\n#' in the 3' UTR gets 1, and the next one 2, ,ect.\n#'\n#' @param org The organism: \"Hs\" for human (hg19), \"Mm\" for mouse (mm10).\n#' @param bed.name The path to the bed file to be intersected\n#' @param bedtools.path The path to bedtools. (e.g \"/path/to/bedtools/bin/\".\n#' End with \"/\", leave \"\" if bedtools is in your PATH environment variable)\n#'\n#' @return a data.frame containing the peak's GTF. Peak ID's consists of the\n#'  gene's ensembl ID, the UTR index, and the peak index ID:\n#'   <ensembl ID>_<UTR index>_<Peak index>. e.g: ENSMUSG00000051951.5_1_2\n#'   has ensembl ID: ENSMUSG00000051951.5, UTR index: 1, peak index 2.\n\n# create_GTF <- function(org, path, bed.name, bedtools.path) {\n#   # home_dir <- getwd()\n#   # on.exit(setwd(home_dir))\n#   # setwd(path)\n#   if (org == \"Mm\") {\n#     data(\"threeprimeUTRs_mm10_M18.gtf\")\n#     write.table(x = threeprimeUTRs_mm10_M18.gtf,\n#                 file = \"./threeprimeUTRs_mm10_M18.gtf\", sep = \"\\t\",\n#                 quote = F, row.names = F, col.names = F)\n#     intersect.command <- paste0(bedtools.path, \"bedtools intersect -wa \",\n#                                 \"-wb -s -a ./\", bed.name,\n#                                 \" -b ./threeprimeUTRs_mm10_M18.gtf >\",\n#                                 \" ./annotatedpeaks\")\n#   }\n#   if (org == \"Hs\") {\n#     data(threeprimeUTRs_hg19_v25_lift37.gtf)\n#     write.table(x = threeprimeUTRs_hg19_v25_lift37.gtf,\n#                 file = \"./threeprimeUTRs_hg19_v25_lift37.gtf\", sep = \"\\t\",\n#                 quote = F, row.names = F, col.names = F)\n#     intersect.command <- paste0(bedtools.path, \"bedtools intersect -wa \",\n#                                 \"-wb -s -a ./\", bed.name,\n#                                 \" -b ./threeprimeUTRs_hg19_v25_lift37.gtf >\",\n#                                 \" ./annotatedpeaks\")\n#   }\n#\n#   system(command = intersect.command, wait = T)\n#   peakstosort <- read.delim(file = \"./annotatedpeaks\", header = F)\n#   peakstosort <- peakstosort[,c(1,8,9,2,3,12:15)]\n#   colnames(peakstosort) <- paste0(\"V\", 1:9)\n#\n#\n#     peakstosort <- dplyr::group_by(peakstosort, V9)\n#     #For peak index: utrs on the plus strand need descending order, minus ascending\n#     peakstosort <- dplyr::mutate(peakstosort,\n#                                  desire = ifelse(V7 == \"+\",\n#                                                  dplyr::dense_rank(x = V4),\n#                                                  dplyr::dense_rank(dplyr::desc(x = V4))))\n#     #this is a column for changing the gene name\n#     peakstosort <- dplyr::mutate(peakstosort,\n#                                  name = paste0(\"_\", desire, \"; transcript_type\"))\n#     peakstosort$V9 <- as.character(peakstosort$V9)\n#         peakstosort <- dplyr::mutate(peakstosort,\n#                                      name2 = paste0(\"_\", desire, \"; transcript_id\"))\n#         for (i in 1:nrow(peakstosort)) {\n#             peakstosort$V9[i] <- gsub(peakstosort$V9[i],\n#                                       pattern = \"; transcript_id\",\n#                                       replacement = peakstosort$name2[i])\n#             #changing the gene name\n#             peakstosort$V9[i] <- gsub(peakstosort$V9[i],\n#                                       pattern = \"; transcript_type\",\n#                                       replacement = peakstosort$name[i])\n#         }\n#     peakstosort <- peakstosort[, 1:9]\n#     peakstosort\n# }\n\nintersect_peaks <- function(org, path, bed.name, bedtools.path, introns = F) {\n  # home_dir <- getwd()\n  # on.exit(setwd(home_dir))\n  # setwd(path)\n  if(!introns){\n  if (org == \"Mm\") {\n    data(mm10.utr)\n    write.bed(.x = mm10.utr,\n                f = \"./threeprimeUTRs.bed\")\n  }\n  if (org == \"Hs\") {\n    data(hg19.utr)\n    write.table(x = hg19.utr,\n                file = \"./threeprimeUTRs.bed\", sep = \"\\t\",\n                quote = F, row.names = F, col.names = F)\n\n  }\n  intersect.command <- paste0(bedtools.path, \"bedtools intersect -wa \",\n                              \"-wb -s -a ./\", bed.name,\n                              \" -b ./threeprimeUTRs.bed >\",\n                              \" ./annotatedpeaks\")\n  system(command = intersect.command, wait = T)\n\n  peakstosort <- read.delim(file = \"./annotatedpeaks\", header = F)\n\n  peakstosort <- peakstosort[,c(1,2,3,10,4,6)]\n  colnames(peakstosort) <- paste0(\"V\", 1:6)\n\n\n  peakstosort <- dplyr::group_by(peakstosort, V4)\n  #For peak index: utrs on the plus strand need descending order, minus ascending\n\n  peakstosort <- dplyr::group_by(peakstosort, V4)\n  #For peak index: utrs on the plus strand need descending order, minus ascending\n  peakstosort <- dplyr::mutate(peakstosort,desire = ifelse(V6 == \"+\",\n                                           dplyr::dense_rank(x = V3),\n                                           dplyr::dense_rank(dplyr::desc(x = V3))))\n  #this is a column for changing the gene name\n  peakstosort$V4 <- paste0(as.character(peakstosort$V4), \"_\", peakstosort$desire)\n  peakstosort <- peakstosort[,-7]\n  system(command = \"rm ./threeprimeUTRs.bed\", wait = T)\n  system(\"rm ./annotatedpeaks\", wait = T)\n  }\n  if(introns){\n    if (org == \"Mm\") {\n      data(mm10.introns)\n      write.bed(.x = mm10.introns,\n                  f= \"./introns.bed\")\n      data(mm10.utr)\n      utrs <- mm10.utr\n    }\n    if (org == \"Hs\") {\n        data(hg19.introns)\n        write.bed(.x = hg19.introns,\n                  f= \"./introns.bed\")\n        data(hg19.utr)\n        utrs <- hg19.utr\n      }\n    intersect.command <- paste0(bedtools.path, \"bedtools intersect -wa \",\n                                \"-wb -s -a ./\", bed.name,\n                                \" -b ./introns.bed >\",\n                                \" ./annotatedpeaks\")\n    system(command = intersect.command, wait = T)\n\n    peakstosort <- read.delim(file = \"./annotatedpeaks\", header = F)\n\n    peakstosort <- peakstosort[,c(1,2,3,10,4,6)]\n    colnames(peakstosort) <- paste0(\"V\", 1:6)\n\n\n    peakstosort <- dplyr::group_by(peakstosort, V4)\n    #For peak index: utrs on the plus strand need descending order, minus ascending\n\n    peakstosort <- dplyr::group_by(peakstosort, V4)\n    #For peak index: utrs on the plus strand need descending order, minus ascending\n    peakstosort <- dplyr::mutate(peakstosort,desire = ifelse(V6 == \"+\",\n                                                             dplyr::dense_rank(x = V3),\n                                                             dplyr::dense_rank(dplyr::desc(x = V3))))\n    #this is a column for changing the gene name\n    peakstosort$V4 <- paste0(as.character(peakstosort$V4), \"_\", peakstosort$desire)\n    peakstosort <- peakstosort[,-7]\n    peakstosort <- rbind.data.frame(peakstosort, utrs)\n    system(command = \"rm ./introns.bed\", wait = T)\n    system(\"rm ./annotatedpeaks\", wait = T)\n  }\n  peakstosort\n}\n\n\n# Mclust ------------------------------------------------------------------\n\nmerge_covrage <- function(files){\ncovrage.list <- lapply(X = samples, read.delim, header = F)\nchnge_col <- function(x){\n  x$V7 <- x$V7 + x$V2 -1\n  x}\nlapply(X = covrage.list, FUN = chnge_col)\ncovrages <- do.call(what = rbind.data.frame, args = covrage.list)\ncovrages  <- dplyr::group_by(covrages, V1, V2, V3, V4, V5, V6, V7)\ncovrages  <- dplyr::summarise(covrages, sum(V8))\ncovrages <- as.data.frame(covrages)\ncovrages <- split(covrages, covrages$V4)\ncovrages\n}\n\n\ncreat_mclus <- function(itemNumber) {\n  wig <- peaks.wig[[itemNumber]]\n  bed <- wig[1,7:12]\n  out <- as.data.frame(bed)\n  if (bed[1,3] - bed[1,2] > 100){\n    vec <-numeric()\n    for(i in 1:nrow(wig)) {\n      if (wig[,2][i] - wig[,3][i]-1 != 0){\n        vec <- c(vec, rep(x = (wig[,2][i]):(wig[,3][i]-1), times = wig[,4][i]))\n      } else {vec <- c(vec, rep(x = (wig[,2][i]), times = wig[,4][i]))}\n    }\n    mod2 <- Mclust(vec, G =2, modelNames = \"E\")\n    meandiff <- abs(mod2$parameters$mean[1]-mod2$parameters$mean[2])\n    diff <- meandiff/sqrt(mod2$parameters$variance$sigmasq[1])\n    if ((diff > 3) & (meandiff > 75)){\n      one <- bed\n      one[,3] <- max(vec[mod2$classification == 1])\n      two <- bed\n      two[,2] <- one[,3] + 1\n      out <- rbind.data.frame(one,two)\n    }\n  }\n  out\n}\n\n# creat_mclus <- function(itemNumber) {\n#   bed <- peaks.bed[[itemNumber]]\n#   bed <- as.data.frame(bed)\n#   out <- bed\n#   if (bed[1,3] - bed[1,2] > 100){\n#     cov <- dplyr::filter(covrage, (pos <= bed[,3] ) & (pos >= bed[,2]))\n#     if(nrow(cov) > 0){\n#\n#\n#     vec <-numeric()\n#     for(i in 1:nrow(cov)) {\n#         vec <- c(vec, rep(x = cov$pos[i], times = cov$dep[i]))\n#     }\n#     if(length(vec) > 0){\n#     mod2 <- Mclust(vec, G = 2, modelNames = \"E\")\n#     meandiff <- abs(mod2$parameters$mean[1]-mod2$parameters$mean[2])\n#     diff <- meandiff/sqrt(mod2$parameters$variance$sigmasq[1])\n#     if ((diff > 3) & (meandiff > 75)){\n#       one <- bed\n#       one[,3] <- max(vec[mod2$classification == 1])\n#       two <- bed\n#       two[,2] <- one[,3] + 1\n#       out <- rbind.data.frame(one,two)\n#     }\n#     }\n#     }\n#   }\n#   out <- as.data.frame(out)\n#   out\n# }\n\ncreat_saf <- function(bed){\n  bed[,4] <- gsub(x = bed[,4], pattern = \"_\\\\d*$\", replacement = \"\")\n  colnames(bed) <- paste0(\"V\", 1:6)\n  bed <- dplyr::group_by(bed, V4)\n  #For peak index: utrs on the plus strand need descending order, minus ascending\n  bed <- dplyr::mutate(bed,desire = ifelse(V6 == \"+\",\n                                           dplyr::dense_rank(x = V3),\n                                           dplyr::dense_rank(dplyr::desc(x = V3))))\n  #this is a column for changing the gene name\n  bed$V4 <- paste0(as.character(bed$V4), \"_\", bed$desire)\n  saf <- as.data.frame(bed[,c(4,1,2,3,6)])\n  colnames(saf) <- c(\"GeneID\", \"Chr\",\t\"Start\",\"End\",\"Strand\")\n  saf\n}\n# generate_covrage <- function(org, path, bed, bedtools.path, bams) {\n# write.bed(.x = bed, f = paste0(path,\"/bed.intersect\"))\n# bams = paste(bams, collapse = \" \")\n# bedtools.covrage.command <- paste0(bedtools.path, \"bedtools coverage -d \",\n#                                  \" -s -a ./bed.intersect -b \",bams, \" > \",\n#                                  \"peak.covrage\")\n# print(bedtools.covrage.command)\n# system(command =bedtools.covrage.command, wait = T)\n# }\n# Reading downstream sequance -----------------------------------------------\nread_down.seq <- function(saf, char.length.path, fasta.path, chr.modify = T) {\n  sc <- options()\n  sc <- sc$scipen\n  options(scipen=99999)\n  on.exit(options(scipen=sc))\n  bed <- saf[,c(2,3,4,1,1,5)]\n  bed[,5] <- \".\"\n  colnames(bed) <- c(\"Chr\", \"Start\", \"End\", \"Peak_ID\", \"f2\", \"Strand\")\n  bed[,4] <- gsub(x =bed[,4], pattern = \";.*\", replacement = \"\")\n  bed[,4] <- gsub(x =bed[,4], pattern = \"gene_id \", replacement = \"\")\n  find_peak_edge <- function(x) {\n    x$Start <- ifelse(x$Strand == \"+\", x$End - 1, x$Start)\n    x$End <- ifelse(x$Strand == \"+\", x$End, x$Start + 1)\n    x\n  }\n  bed.edge <- find_peak_edge(bed)\n  #modify chromosoms names\n  if(chr.modify){\n  bed.edge[,1] <- ifelse(bed.edge$Chr == \"MT\", \"chrM\", paste0(\"chr\",\n                                                              bed.edge[,1]))\n  }\n  write.table(bed.edge, file = \"./bed.edge\", sep = \"\\t\", quote = F,\n              col.names = F, row.names = F)\n  slop.command <- paste0(bedtools.path, \"bedtools slop -s -r 200 -l -1 -g \",\n                           char.length.path, \" -i ./bed.edge > \",\n                         \"./bed.extended\")\n  system(command = slop.command, wait = T)\n    bed.fasta.command <- paste0(bedtools.path, \"bedtools getfasta -s -tab\",\n                                \" -fi \", fasta.path,\n                                \" -bed ./bed.extended -fo \",\n                                \"./bed.extended.fa\")\n  system(command = bed.fasta.command, wait = T)\n  fasta <- read.delim(file = \"./bed.extended.fa\", header = F,\n                      col.names = c(\"region\", \"seq\"))\n  out <- cbind.data.frame(bed[,-5], fasta[,-1])\n  colnames(out)[6] <- \"Downstream_Seq\"\n  system(command = \"rm ./bed.extended.fa ./bed.extended\", wait = T)\n  out\n}\n\n\n# Proccess DigitalExpression output and cluster files ----------------------------------\n\nprocess_cluster.files <- function(sample.names){\npath.clus.files <- paste0(\"../clusters_\", sample.names,\".txt\")\nclusters <- lapply(X = path.clus.files, FUN = read.delim, header = F)\n#As diffrent samples may have identical cell BC, we replace the suffix (-1), to\n# an index corresponding to the sample. The same is done for the expression file\n# file.\nfor (nsample in 1:length(clusters)) {\n  clusters[[nsample]][,1] <- gsub(x =clusters[[nsample]][,1],\n                                  pattern = \"-\\\\d*$\",\n                                  replacement = \"-1\")\n\n  clusters[[nsample]][,1] <- paste0(sample.names[nsample],\"_\", clusters[[nsample]][,1])\n  }\ndo.call(what = \"rbind\", args = clusters)\n}\n\nprocess_expression <- function(org, path.exp.mats) {\nexpression[is.na(expression)] <- 0\ncolnames(expression) <- gsub(x = colnames(expression), pattern = \"[.]\",\n                           replacement = \"-\")\nexpression\n}\n\n\n",
    "created" : 1562758805164.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1385001245",
    "id" : "8C56B053",
    "lastKnownWriteTime" : 1562763870,
    "last_content_update" : 1562763870600,
    "path" : "/specific/netapp5_2/elkon/eldadshulman/scAPA/R/GTF_create.R",
    "project_path" : "R/GTF_create.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}